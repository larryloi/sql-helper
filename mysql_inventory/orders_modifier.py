#!/usr/bin/env python3
"""
Orders Modifier Service

This service continuously modifies order statuses in the database based on configuration.
It supports multiple processes and includes comprehensive error handling and logging.

Author: Generated by AI Assistant
Version: 2.0.0
"""

import os
import sys
import random
import time
import signal
import yaml
from datetime import datetime, timedelta
import pytz
import sqlalchemy
from sqlalchemy import create_engine, Table, MetaData, select, update
from multiprocessing import Process, Event
import logging
from contextlib import contextmanager
from typing import Dict, List, Optional, Tuple
from db_handler import DBConnectionHandler, load_config

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'common')))
import my_logging

# Global configuration
local_tz = pytz.timezone('Asia/Macau')
shutdown_event = Event()

class OrdersModifierConfig:
    """Configuration handler for Orders Modifier service."""
    
    def __init__(self, config_path: Optional[str] = None):
        """Initialize configuration.
        
        Args:
            config_path: Optional path to configuration file
        """
        self.config = load_config(config_path) if config_path else load_config()
        self.service_config = self.config['services']['orders_modifier']
        self._validate_config()
    
    def _validate_config(self) -> None:
        """Validate required configuration parameters."""
        required_keys = ['DATABASE_URL', 'WAIT_TIME', 'STATUS', 'NUM_PROCESSES', 'RAND_LAST_HOURS']
        for key in required_keys:
            if key not in self.service_config:
                raise ValueError(f"Missing required configuration key: {key}")
    
    @property
    def db_url(self) -> str:
        return self.service_config['DATABASE_URL']
    
    @property
    def wait_time(self) -> List[int]:
        return self.service_config['WAIT_TIME']
    
    @property
    def status(self) -> Dict[str, float]:
        return self.service_config['STATUS']
    
    @property
    def num_processes(self) -> int:
        return self.service_config['NUM_PROCESSES']
    
    @property
    def rand_last_hours(self) -> int:
        return self.service_config['RAND_LAST_HOURS']
    
    @property
    def timeout_seconds(self) -> int:
        return self.config['services']['default_config']['TIMEOUT_SECONDS']
    
    @property
    def max_retries(self) -> int:
        return self.config['services']['default_config']['MAX_RETRIES']

class OrdersModifier:
    """Orders modifier service with enhanced error handling and logging."""
    
    def __init__(self, config: OrdersModifierConfig, process_id: int = 0):
        """Initialize Orders Modifier.
        
        Args:
            config: Configuration object
            process_id: Process identifier for logging
        """
        self.config = config
        self.process_id = process_id
        self.logger = logging.getLogger(f"{__name__}.process_{process_id}")
        self.db_handler = None
        self.orders_table = None
        self.stats = {
            'total_attempts': 0,
            'successful_updates': 0,
            'failed_updates': 0,
            'no_records_found': 0
        }
    
    def _setup_database(self) -> None:
        """Setup database connection and table metadata."""
        self.db_handler = DBConnectionHandler(
            db_url=self.config.db_url,
            timeout_seconds=self.config.timeout_seconds,
            max_retries=self.config.max_retries
        )
        
        try:
            self.db_handler.connect()
            engine = self.db_handler.get_engine()
            metadata = MetaData()
            self.orders_table = Table('orders', metadata, autoload_with=engine)
            self.logger.info(f"Process {self.process_id}: Database connection established")
        except Exception as e:
            self.logger.error(f"Process {self.process_id}: Failed to setup database: {e}")
            raise
    
    @contextmanager
    def database_transaction(self):
        """Context manager for database transactions."""
        if not self.db_handler:
            raise RuntimeError("Database handler not initialized")
        
        engine = self.db_handler.get_engine()
        connection = engine.connect()
        transaction = connection.begin()
        
        try:
            yield connection
            transaction.commit()
        except Exception as e:
            transaction.rollback()
            self.logger.error(f"Process {self.process_id}: Transaction rolled back due to error: {e}")
            raise
        finally:
            connection.close()
    
    def _get_random_order(self, connection) -> Optional[Dict]:
        """Get a random order within the specified time range.
        
        Args:
            connection: Database connection
            
        Returns:
            Order record or None if no records found
        """
        try:
            random_time = datetime.now(local_tz) - timedelta(hours=random.random() * self.config.rand_last_hours)
            
            select_stmt = (
                select(self.orders_table)
                .where(self.orders_table.c.created_at >= random_time)
                .order_by(self.orders_table.c.id)
                .limit(1)
            )
            
            result = connection.execute(select_stmt)
            row = result.fetchone()
            
            if row:
                self.logger.debug(f"Process {self.process_id}: Found order {row['id']} created after {random_time}")
                return dict(row)
            else:
                self.logger.debug(f"Process {self.process_id}: No orders found after {random_time}")
                self.stats['no_records_found'] += 1
                return None
                
        except Exception as e:
            self.logger.error(f"Process {self.process_id}: Error selecting random order: {e}")
            raise
    
    def _update_order_status(self, connection, order_id: int) -> bool:
        """Update order status.
        
        Args:
            connection: Database connection
            order_id: Order ID to update
            
        Returns:
            True if successful, False otherwise
        """
        try:
            random_status = random.choices(
                list(self.config.status.keys()),
                weights=list(self.config.status.values())
            )[0]
            
            update_stmt = (
                update(self.orders_table)
                .where(self.orders_table.c.id == order_id)
                .values({
                    "status": random_status,
                    "updated_at": datetime.now(local_tz)
                })
            )
            
            self.logger.info(
                f"Process {self.process_id}: Updating order {order_id} to status '{random_status}'"
            )
            
            result = connection.execute(update_stmt)
            
            if result.rowcount > 0:
                self.stats['successful_updates'] += 1
                return True
            else:
                self.logger.warning(f"Process {self.process_id}: No rows updated for order {order_id}")
                self.stats['failed_updates'] += 1
                return False
                
        except Exception as e:
            self.logger.error(f"Process {self.process_id}: Error updating order {order_id}: {e}")
            self.stats['failed_updates'] += 1
            raise
    
    def _log_statistics(self) -> None:
        """Log process statistics."""
        self.logger.info(
            f"Process {self.process_id} Stats - "
            f"Attempts: {self.stats['total_attempts']}, "
            f"Successful: {self.stats['successful_updates']}, "
            f"Failed: {self.stats['failed_updates']}, "
            f"No Records: {self.stats['no_records_found']}"
        )
    
    def run(self) -> None:
        """Main execution loop for the orders modifier."""
        self.logger.info(f"Process {self.process_id}: Starting orders modifier")
        
        try:
            self._setup_database()
            
            stats_counter = 0
            
            while not shutdown_event.is_set():
                try:
                    wait_time_seconds = random.randint(
                        self.config.wait_time[0],
                        self.config.wait_time[1]
                    )
                    
                    self.logger.debug(
                        f"Process {self.process_id}: Waiting {wait_time_seconds} seconds before next update"
                    )
                    
                    # Interruptible sleep
                    for _ in range(wait_time_seconds):
                        if shutdown_event.is_set():
                            break
                        time.sleep(1)
                    
                    if shutdown_event.is_set():
                        break
                    
                    self.stats['total_attempts'] += 1
                    
                    with self.database_transaction() as connection:
                        order = self._get_random_order(connection)
                        if order:
                            self._update_order_status(connection, order['id'])
                    
                    # Log statistics every 10 attempts
                    stats_counter += 1
                    if stats_counter >= 10:
                        self._log_statistics()
                        stats_counter = 0
                        
                except sqlalchemy.exc.ProgrammingError as e:
                    self.logger.warning(f"Process {self.process_id}: Programming error (likely transient): {e}")
                    self.stats['failed_updates'] += 1
                    continue
                except Exception as e:
                    self.logger.error(f"Process {self.process_id}: Unexpected error in main loop: {e}")
                    self.stats['failed_updates'] += 1
                    # Brief pause before retrying
                    time.sleep(5)
                    continue
                    
        except Exception as e:
            self.logger.critical(f"Process {self.process_id}: Critical error, shutting down: {e}")
            raise
        finally:
            self._cleanup()
    
    def _cleanup(self) -> None:
        """Cleanup resources."""
        try:
            self._log_statistics()
            if self.db_handler:
                self.db_handler.close()
            self.logger.info(f"Process {self.process_id}: Cleanup completed")
        except Exception as e:
            self.logger.error(f"Process {self.process_id}: Error during cleanup: {e}")

def signal_handler(signum, frame):
    """Handle shutdown signals."""
    logging.info(f"Received signal {signum}, initiating graceful shutdown...")
    shutdown_event.set()

def worker_process(config: OrdersModifierConfig, process_id: int) -> None:
    """Worker process function.
    
    Args:
        config: Configuration object
        process_id: Process identifier
    """
    # Setup signal handlers for graceful shutdown
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    modifier = OrdersModifier(config, process_id)
    
    try:
        modifier.run()
    except KeyboardInterrupt:
        logging.info(f"Process {process_id}: Interrupted by user")
    except Exception as e:
        logging.error(f"Process {process_id}: Fatal error: {e}")
        raise

if __name__ == "__main__":
    # Setup signal handlers for the main process
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    try:
        # Load configuration
        config = OrdersModifierConfig()
        processes = []
        
        # Start worker processes
        for i in range(config.num_processes):
            p = Process(target=worker_process, args=(config, i))
            p.start()
            logging.info(f"Started worker process {i} with PID: {p.pid}")
            processes.append(p)
        
        # Wait for all processes to complete
        for p in processes:
            p.join()
    except KeyboardInterrupt:
        logging.info("Main process received keyboard interrupt, initiating shutdown...")
        shutdown_event.set()
        
        # Wait for worker processes to terminate gracefully
        for p in processes:
            p.join(timeout=10)  # Give each process up to 10 seconds to shut down
            if p.is_alive():
                logging.warning(f"Process {p.pid} still running, terminating...")
                p.terminate()
    except Exception as e:
        logging.error(f"Main process error: {e}")
        shutdown_event.set()
    finally:
        logging.info("All processes completed, exiting.")
