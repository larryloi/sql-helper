#!/usr/bin/env python3
"""
Orders Purger Service

This service continuously purges old orders from the database based on retention policy.
It includes comprehensive error handling, statistics tracking, and graceful shutdown.

Author: Generated by AI Assistant
Version: 2.0.0
"""

import os
import sys
import yaml
import random
import time
import signal
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import pytz
import sqlalchemy
from sqlalchemy import create_engine, Table, MetaData, select, func, text
from contextlib import contextmanager
import logging
from db_handler import DBConnectionHandler, load_config

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'common')))
import my_logging

# Global configuration
local_tz = pytz.timezone('Asia/Macau')
shutdown_requested = False

class OrdersPurgerConfig:
    """Configuration handler for Orders Purger service."""
    
    def __init__(self, config_path: Optional[str] = None):
        """Initialize configuration.
        
        Args:
            config_path: Optional path to configuration file
        """
        self.config = load_config(config_path) if config_path else load_config()
        self.service_config = self.config['services']['orders_purger']
        self._validate_config()
    
    def _validate_config(self) -> None:
        """Validate required configuration parameters."""
        required_keys = ['DATABASE_URL', 'WAIT_TIME', 'RETENTION_HOURS', 'BATCH_SIZE']
        for key in required_keys:
            if key not in self.service_config:
                raise ValueError(f"Missing required configuration key: {key}")
        
        # Validate ranges
        if len(self.service_config['WAIT_TIME']) != 2:
            raise ValueError("WAIT_TIME must be a list with exactly 2 elements [min, max]")
        
        if self.service_config['BATCH_SIZE'] <= 0:
            raise ValueError("BATCH_SIZE must be positive")
        
        if self.service_config['RETENTION_HOURS'] <= 0:
            raise ValueError("RETENTION_HOURS must be positive")
    
    @property
    def db_url(self) -> str:
        return self.service_config['DATABASE_URL']
    
    @property
    def wait_time(self) -> List[int]:
        return self.service_config['WAIT_TIME']
    
    @property
    def retention_hours(self) -> int:
        return self.service_config['RETENTION_HOURS']
    
    @property
    def batch_size(self) -> int:
        return self.service_config['BATCH_SIZE']
    
    @property
    def timeout_seconds(self) -> int:
        return self.config['services']['default_config']['TIMEOUT_SECONDS']
    
    @property
    def max_retries(self) -> int:
        return self.config['services']['default_config']['MAX_RETRIES']
    
    @property
    def dry_run(self) -> bool:
        """Check if this is a dry run (for testing purposes)."""
        return self.service_config.get('DRY_RUN', False)

class OrdersPurger:
    """Orders purger service with enhanced error handling and logging."""
    
    def __init__(self, config: OrdersPurgerConfig):
        """Initialize Orders Purger.
        
        Args:
            config: Configuration object
        """
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.db_handler = None
        self.orders_table = None
        self.stats = {
            'total_cycles': 0,
            'total_purged': 0,
            'total_batches': 0,
            'largest_batch': 0,
            'errors': 0,
            'start_time': datetime.now(local_tz)
        }
    
    def _setup_database(self) -> None:
        """Setup database connection and table metadata."""
        self.db_handler = DBConnectionHandler(
            db_url=self.config.db_url,
            timeout_seconds=self.config.timeout_seconds,
            max_retries=self.config.max_retries
        )
        
        try:
            self.db_handler.connect()
            engine = self.db_handler.get_engine()
            metadata = MetaData()
            self.orders_table = Table('orders', metadata, autoload_with=engine)
            self.logger.info("Database connection established")
        except Exception as e:
            self.logger.error(f"Failed to setup database: {e}")
            raise
    
    @contextmanager
    def database_transaction(self):
        """Context manager for database transactions."""
        if not self.db_handler:
            raise RuntimeError("Database handler not initialized")
        
        engine = self.db_handler.get_engine()
        connection = engine.connect()
        transaction = connection.begin()
        
        try:
            yield connection
            transaction.commit()
        except Exception as e:
            transaction.rollback()
            self.logger.error(f"Transaction rolled back due to error: {e}")
            raise
        finally:
            connection.close()
    
    def _get_orders_to_purge(self, connection) -> List[str]:
        """Get orders that are eligible for purging.
        
        Args:
            connection: Database connection
            
        Returns:
            List of order_ids to purge
        """
        try:
            # Use a more explicit and safe query
            select_stmt = (
                select(self.orders_table.c.order_id)
                .where(
                    text(f"TIMESTAMPDIFF(HOUR, updated_at, NOW()) > :retention_hours")
                )
                .limit(self.config.batch_size)
            )
            
            result = connection.execute(select_stmt, retention_hours=self.config.retention_hours)
            rows = result.fetchall()
            
            order_ids = [row['order_id'] for row in rows]
            
            if order_ids:
                self.logger.debug(f"Found {len(order_ids)} orders to purge")
            else:
                self.logger.debug("No orders found for purging")
            
            return order_ids
            
        except Exception as e:
            self.logger.error(f"Error selecting orders to purge: {e}")
            raise
    
    def _purge_orders_batch(self, connection, order_ids: List[str]) -> int:
        """Purge a batch of orders.
        
        Args:
            connection: Database connection
            order_ids: List of order IDs to purge
            
        Returns:
            Number of rows actually deleted
        """
        try:
            if self.config.dry_run:
                self.logger.info(f"DRY RUN: Would delete {len(order_ids)} orders")
                return len(order_ids)  # Simulate deletion
            
            delete_stmt = self.orders_table.delete().where(
                self.orders_table.c.order_id.in_(order_ids)
            )
            
            result = connection.execute(delete_stmt)
            deleted_count = result.rowcount
            
            self.logger.info(
                f"Purged {deleted_count} orders (batch size: {len(order_ids)})"
            )
            
            # Track statistics
            self.stats['total_purged'] += deleted_count
            self.stats['total_batches'] += 1
            self.stats['largest_batch'] = max(self.stats['largest_batch'], deleted_count)
            
            return deleted_count
            
        except Exception as e:
            self.logger.error(f"Error purging orders batch: {e}")
            self.stats['errors'] += 1
            raise
    
    def _get_table_statistics(self, connection) -> Dict[str, int]:
        """Get current table statistics.
        
        Args:
            connection: Database connection
            
        Returns:
            Dictionary with table statistics
        """
        try:
            # Total count
            total_count_stmt = select(func.count(self.orders_table.c.id))
            total_result = connection.execute(total_count_stmt)
            total_count = total_result.scalar()
            
            # Eligible for purging count
            eligible_count_stmt = select(
                func.count(self.orders_table.c.id)
            ).where(
                text(f"TIMESTAMPDIFF(HOUR, updated_at, NOW()) > :retention_hours")
            )
            eligible_result = connection.execute(
                eligible_count_stmt, retention_hours=self.config.retention_hours
            )
            eligible_count = eligible_result.scalar()
            
            return {
                'total_orders': total_count,
                'eligible_for_purge': eligible_count
            }
            
        except Exception as e:
            self.logger.error(f"Error getting table statistics: {e}")
            return {'total_orders': 0, 'eligible_for_purge': 0}
    
    def _log_statistics(self, table_stats: Optional[Dict[str, int]] = None) -> None:
        """Log purger statistics.
        
        Args:
            table_stats: Optional table statistics
        """
        runtime = datetime.now(local_tz) - self.stats['start_time']
        
        stats_msg = (
            f"Purger Stats - Runtime: {runtime}, "
            f"Cycles: {self.stats['total_cycles']}, "
            f"Total Purged: {self.stats['total_purged']}, "
            f"Batches: {self.stats['total_batches']}, "
            f"Largest Batch: {self.stats['largest_batch']}, "
            f"Errors: {self.stats['errors']}"
        )
        
        if table_stats:
            stats_msg += (
                f", Current Orders: {table_stats['total_orders']}, "
                f"Eligible for Purge: {table_stats['eligible_for_purge']}"
            )
        
        self.logger.info(stats_msg)
    
    def run(self) -> None:
        """Main execution loop for the orders purger."""
        self.logger.info(f"Starting orders purger (PID: {os.getpid()})")
        self.logger.info(
            f"Configuration - Retention: {self.config.retention_hours}h, "
            f"Batch Size: {self.config.batch_size}, "
            f"Wait Time: {self.config.wait_time[0]}-{self.config.wait_time[1]}s"
        )
        
        if self.config.dry_run:
            self.logger.info("RUNNING IN DRY RUN MODE - No actual deletions will occur")
        
        try:
            self._setup_database()
            
            stats_counter = 0
            
            while not shutdown_requested:
                try:
                    self.stats['total_cycles'] += 1
                    
                    # Get table statistics periodically
                    table_stats = None
                    if stats_counter % 10 == 0:  # Every 10 cycles
                        with self.database_transaction() as connection:
                            table_stats = self._get_table_statistics(connection)
                    
                    # Calculate wait time
                    wait_time_seconds = random.randint(
                        self.config.wait_time[0],
                        self.config.wait_time[1]
                    )
                    
                    self.logger.debug(
                        f"Waiting {wait_time_seconds} seconds before next purge cycle"
                    )
                    
                    # Interruptible sleep
                    for _ in range(wait_time_seconds):
                        if shutdown_requested:
                            break
                        time.sleep(1)
                    
                    if shutdown_requested:
                        break
                    
                    # Purge cycle
                    with self.database_transaction() as connection:
                        # Get orders to purge
                        order_ids = self._get_orders_to_purge(connection)
                        
                        while order_ids and not shutdown_requested:
                            # Purge this batch
                            deleted_count = self._purge_orders_batch(connection, order_ids)
                            
                            if deleted_count == 0:
                                # No more rows to delete, break
                                break
                            
                            # Check for more orders to purge
                            order_ids = self._get_orders_to_purge(connection)
                    
                    # Log statistics periodically
                    stats_counter += 1
                    if stats_counter >= 10:
                        self._log_statistics(table_stats)
                        stats_counter = 0
                        
                except sqlalchemy.exc.ProgrammingError as e:
                    self.logger.warning(f"Programming error (likely transient): {e}")
                    self.stats['errors'] += 1
                    continue
                except Exception as e:
                    self.logger.error(f"Unexpected error in main loop: {e}")
                    self.stats['errors'] += 1
                    # Brief pause before retrying
                    time.sleep(5)
                    continue
                    
        except Exception as e:
            self.logger.critical(f"Critical error, shutting down: {e}")
            raise
        finally:
            self._cleanup()
    
    def _cleanup(self) -> None:
        """Cleanup resources."""
        try:
            self._log_statistics()
            if self.db_handler:
                self.db_handler.close()
            self.logger.info("Cleanup completed")
        except Exception as e:
            self.logger.error(f"Error during cleanup: {e}")

def signal_handler(signum, frame):
    """Handle shutdown signals."""
    global shutdown_requested
    logging.info(f"Received signal {signum}, initiating graceful shutdown...")
    shutdown_requested = True

if __name__ == "__main__":
    # Setup signal handlers
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    try:
        # Load configuration
        config = OrdersPurgerConfig()
        purger = OrdersPurger(config)
        
        # Start purging
        purger.run()
        
    except KeyboardInterrupt:
        logging.info("Received keyboard interrupt, shutting down...")
    except Exception as e:
        logging.error(f"Fatal error: {e}")
        sys.exit(1)
    finally:
        logging.info("Orders purger exited.")
